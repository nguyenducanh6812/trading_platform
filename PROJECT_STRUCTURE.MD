# Modern Portfolio Theory Trading Platform - Spring Boot Module Architecture

## ğŸ›ï¸ **Module-Based Spring Boot Architecture (Microservices-Ready)**

```
trading_platform/
â”œâ”€â”€ ğŸ“¦ src/main/java/com/ahd/trading_platform/   # Spring Boot Application Root
â”‚   â”œâ”€â”€ ğŸ”¸ marketdata/                           # âœ… Market Data Module (Completed)
â”‚   â”‚   â”œâ”€â”€ domain/                              # Domain Layer - Pure Business Logic
â”‚   â”‚   â”‚   â”œâ”€â”€ entities/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ MarketInstrument.java        # Aggregate root with OHLCV price history
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ PriceData.java               # Price data entity
â”‚   â”‚   â”‚   â”œâ”€â”€ valueobjects/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Price.java                   # Immutable price record
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ OHLCV.java                   # Open-High-Low-Close-Volume record
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ TimeRange.java               # Time period for queries
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ TradingInstrument.java       # BTC, ETH enum
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ DataQualityMetrics.java      # Data validation metrics
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ BybitMarketType.java         # LINEAR futures market type
â”‚   â”‚   â”‚   â”œâ”€â”€ repositories/                    # Repository contracts
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ MarketInstrumentRepository.java
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ BtcPriceRepository.java      # Asset-specific repositories
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ EthPriceRepository.java
â”‚   â”‚   â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ DataValidationService.java   # Domain validation logic
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ExternalDataClientStrategy.java # Strategy pattern interface
â”‚   â”‚   â”‚   â””â”€â”€ events/
â”‚   â”‚   â”‚       â””â”€â”€ MarketDataUpdatedEvent.java  # Domain events
â”‚   â”‚   â”œâ”€â”€ application/                         # Application Layer - Use Cases
â”‚   â”‚   â”‚   â”œâ”€â”€ usecases/
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ FetchHistoricalDataUseCase.java # Main use case
â”‚   â”‚   â”‚   â”œâ”€â”€ dto/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ MarketDataRequest.java       # API request DTOs
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ MarketDataResponse.java      # API response DTOs
â”‚   â”‚   â”‚   â””â”€â”€ services/
â”‚   â”‚   â”‚       â””â”€â”€ MarketDataApplicationService.java
â”‚   â”‚   â”œâ”€â”€ infrastructure/                      # Infrastructure Layer
â”‚   â”‚   â”‚   â”œâ”€â”€ external/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ BybitFeignClient.java        # External API client
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ BybitDataClientStrategy.java # Strategy implementation
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ExternalDataClientFactory.java # Strategy factory
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ mappers/
â”‚   â”‚   â”‚   â”‚       â””â”€â”€ BybitMapper.java         # Data mapping
â”‚   â”‚   â”‚   â”œâ”€â”€ persistence/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ entities/                    # JPA entities
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ MarketInstrumentEntity.java
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ BtcPriceEntity.java      # Asset-specific tables
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ EthPriceEntity.java
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ repositories/
â”‚   â”‚   â”‚   â”‚       â””â”€â”€ JpaMarketInstrumentRepository.java
â”‚   â”‚   â”‚   â””â”€â”€ config/
â”‚   â”‚   â”‚       â”œâ”€â”€ MarketDataConfiguration.java # Spring configuration
â”‚   â”‚   â”‚       â”œâ”€â”€ MarketDataProperties.java    # Configuration properties
â”‚   â”‚   â”‚       â””â”€â”€ RateLimiterConfig.java       # Resilience4j rate limiting
â”‚   â”‚   â””â”€â”€ interfaces/                          # Interface Layer
â”‚   â”‚       â”œâ”€â”€ rest/
â”‚   â”‚       â”‚   â””â”€â”€ MarketDataController.java    # REST endpoints
â”‚   â”‚       â””â”€â”€ camunda/
â”‚   â”‚           â””â”€â”€ FetchInstrumentDataTaskWorker.java # External task worker
â”‚   â”‚
â”‚   â”œâ”€â”€ ğŸ”¸ analytics/                           # ğŸ†• Analytics Module (Trading Model Phase 1 & 2)
â”‚   â”‚   â”œâ”€â”€ domain/
â”‚   â”‚   â”‚   â”œâ”€â”€ entities/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ TradingModel.java            # Phase 1 & 2 aggregate root
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ OptimizationResult.java      # Sharpe ratio optimization result
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ StrategyRecommendation.java  # Final recommendation
â”‚   â”‚   â”‚   â”œâ”€â”€ valueobjects/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ExpectedReturn.java          # Phase 1 input
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ SharpeRatio.java            # Optimization target
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ PortfolioWeights.java       # Phase 1 output
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ RiskPreference.java         # Phase 2 input (Averse/Neutral/Lover)
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ RiskAdjustedWeights.java    # Phase 2 output
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ CovarianceMatrix.java       # Risk calculations
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ConstraintSet.java          # Investment constraints
â”‚   â”‚   â”‚   â”œâ”€â”€ repositories/
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ TradingModelRepository.java
â”‚   â”‚   â”‚   â””â”€â”€ services/
â”‚   â”‚   â”‚       â”œâ”€â”€ ExpectedReturnCalculator.java    # Calculates from historical data
â”‚   â”‚   â”‚       â”œâ”€â”€ SharpeRatioOptimizer.java       # Phase 1: Max Sharpe Ratio
â”‚   â”‚   â”‚       â”œâ”€â”€ RiskAdjustmentService.java      # Phase 2: Risk preference
â”‚   â”‚   â”‚       â””â”€â”€ CovarianceCalculator.java       # Risk matrix calculations
â”‚   â”‚   â”œâ”€â”€ application/
â”‚   â”‚   â”‚   â”œâ”€â”€ usecases/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ CalculateExpectedReturnsUseCase.java
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ OptimizeForSharpeRatioUseCase.java    # Phase 1
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ AdjustForRiskPreferenceUseCase.java   # Phase 2
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ RunTradingModelUseCase.java           # Orchestrates both phases
â”‚   â”‚   â”‚   â””â”€â”€ dto/
â”‚   â”‚   â”‚       â”œâ”€â”€ OptimizationRequest.java
â”‚   â”‚   â”‚       â””â”€â”€ TradingModelResult.java
â”‚   â”‚   â”œâ”€â”€ infrastructure/
â”‚   â”‚   â”‚   â”œâ”€â”€ optimization/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ QuadraticProgrammingOptimizer.java   # Optimization engine
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ApacheCommonsOptimizer.java          # Alternative implementation
â”‚   â”‚   â”‚   â””â”€â”€ persistence/
â”‚   â”‚   â”‚       â””â”€â”€ entities/
â”‚   â”‚   â”‚           â””â”€â”€ TradingModelResultEntity.java
â”‚   â”‚   â””â”€â”€ interfaces/
â”‚   â”‚       â”œâ”€â”€ rest/
â”‚   â”‚       â”‚   â””â”€â”€ AnalyticsController.java
â”‚   â”‚       â””â”€â”€ camunda/
â”‚   â”‚           â””â”€â”€ RunTradingModelWorker.java
â”‚   â”‚
â”‚   â”œâ”€â”€ ğŸ”¸ forecasting/                         # ğŸ†• Forecasting Module (Phase 3 - ARIMA)
â”‚   â”‚   â”œâ”€â”€ domain/
â”‚   â”‚   â”‚   â”œâ”€â”€ entities/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ARIMAModel.java              # Phase 3 aggregate root
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ForecastResult.java          # Prediction results
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ StationarityTest.java        # Statistical test results
â”‚   â”‚   â”‚   â”œâ”€â”€ valueobjects/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ARIMAParameters.java         # (p,d,q) parameters
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ForecastHorizon.java         # Prediction time window
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ConfidenceInterval.java      # Prediction bounds
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ StationarityMetrics.java     # ADF test results
â”‚   â”‚   â”‚   â”œâ”€â”€ repositories/
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ARIMAModelRepository.java
â”‚   â”‚   â”‚   â””â”€â”€ services/
â”‚   â”‚   â”‚       â”œâ”€â”€ StationarityTestService.java     # Phase 3: Stationarity testing
â”‚   â”‚   â”‚       â”œâ”€â”€ ARIMAParameterOptimizer.java     # Model selection (p,d,q)
â”‚   â”‚   â”‚       â””â”€â”€ ForecastGeneratorService.java    # Generate predictions
â”‚   â”‚   â”œâ”€â”€ application/
â”‚   â”‚   â”‚   â”œâ”€â”€ usecases/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ TestStationarityUseCase.java
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ OptimizeARIMAParametersUseCase.java
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ GenerateForecastUseCase.java
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ PredictExpectedReturnsUseCase.java   # Main Phase 3 use case
â”‚   â”‚   â”‚   â””â”€â”€ dto/
â”‚   â”‚   â”‚       â”œâ”€â”€ ForecastRequest.java
â”‚   â”‚   â”‚       â””â”€â”€ ForecastResponse.java
â”‚   â”‚   â”œâ”€â”€ infrastructure/
â”‚   â”‚   â”‚   â”œâ”€â”€ forecasting/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ApacheCommonsARIMA.java       # ARIMA implementation
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ WEKATimeSeriesEngine.java     # Alternative ML approach
â”‚   â”‚   â”‚   â””â”€â”€ persistence/
â”‚   â”‚   â”‚       â””â”€â”€ entities/
â”‚   â”‚   â”‚           â””â”€â”€ ARIMAModelEntity.java
â”‚   â”‚   â””â”€â”€ interfaces/
â”‚   â”‚       â”œâ”€â”€ rest/
â”‚   â”‚       â”‚   â””â”€â”€ ForecastingController.java
â”‚   â”‚       â””â”€â”€ camunda/
â”‚   â”‚           â””â”€â”€ GenerateForecastWorker.java
â”‚   â”‚
â”‚   â”œâ”€â”€ ğŸ”¸ backtesting/                         # ğŸ†• Backtesting Module
â”‚   â”‚   â”œâ”€â”€ domain/
â”‚   â”‚   â”‚   â”œâ”€â”€ entities/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ BacktestSession.java         # Historical test aggregate root
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ BacktestResult.java          # Performance results
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ TradingSimulation.java       # Simulation execution
â”‚   â”‚   â”‚   â”œâ”€â”€ valueobjects/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ BacktestPeriod.java          # Historical time range
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ PerformanceMetrics.java      # Sharpe, volatility, drawdown
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ SimulationConfig.java        # Test parameters
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ TradeSimulation.java         # Individual trade simulation
â”‚   â”‚   â”‚   â”œâ”€â”€ repositories/
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ BacktestRepository.java
â”‚   â”‚   â”‚   â””â”€â”€ services/
â”‚   â”‚   â”‚       â”œâ”€â”€ BacktestEngineService.java       # Main backtesting logic
â”‚   â”‚   â”‚       â”œâ”€â”€ PerformanceCalculatorService.java # Metrics calculation
â”‚   â”‚   â”‚       â””â”€â”€ ComparisonAnalysisService.java    # Strategy comparison
â”‚   â”‚   â”œâ”€â”€ application/
â”‚   â”‚   â”‚   â”œâ”€â”€ usecases/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ RunBacktestUseCase.java
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ AnalyzePerformanceUseCase.java
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ CompareStrategiesUseCase.java
â”‚   â”‚   â”‚   â””â”€â”€ dto/
â”‚   â”‚   â”‚       â”œâ”€â”€ BacktestRequest.java
â”‚   â”‚   â”‚       â””â”€â”€ BacktestReport.java
â”‚   â”‚   â”œâ”€â”€ infrastructure/
â”‚   â”‚   â”‚   â”œâ”€â”€ simulation/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ VectorizedBacktester.java    # High-performance backtesting
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ EventDrivenBacktester.java   # Realistic simulation
â”‚   â”‚   â”‚   â””â”€â”€ persistence/
â”‚   â”‚   â”‚       â””â”€â”€ entities/
â”‚   â”‚   â”‚           â””â”€â”€ BacktestResultEntity.java
â”‚   â”‚   â””â”€â”€ interfaces/
â”‚   â”‚       â”œâ”€â”€ rest/
â”‚   â”‚       â”‚   â””â”€â”€ BacktestingController.java
â”‚   â”‚       â””â”€â”€ camunda/
â”‚   â”‚           â””â”€â”€ RunBacktestWorker.java
â”‚   â”‚
â”‚   â”œâ”€â”€ ğŸ”¸ portfolio/                           # ğŸ†• Portfolio Module (Real Portfolio Management)
â”‚   â”‚   â”œâ”€â”€ domain/
â”‚   â”‚   â”‚   â”œâ”€â”€ entities/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Portfolio.java               # Real portfolio aggregate root
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Position.java                # Individual asset positions
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Trade.java                   # Executed trades
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ RebalanceOrder.java          # Rebalancing instructions
â”‚   â”‚   â”‚   â”œâ”€â”€ valueobjects/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ PortfolioValue.java          # Total portfolio value
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Allocation.java              # Current asset allocation
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ RebalanceInstruction.java    # Trading instructions
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ RiskExposure.java            # Current risk metrics
â”‚   â”‚   â”‚   â”œâ”€â”€ repositories/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ PortfolioRepository.java
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ TradeRepository.java
â”‚   â”‚   â”‚   â””â”€â”€ services/
â”‚   â”‚   â”‚       â”œâ”€â”€ RebalancingService.java          # Uses analytics results
â”‚   â”‚   â”‚       â”œâ”€â”€ RiskMonitoringService.java       # Real-time risk tracking
â”‚   â”‚   â”‚       â”œâ”€â”€ PerformanceTrackingService.java  # Portfolio performance
â”‚   â”‚   â”‚       â””â”€â”€ TradeExecutionService.java       # Order execution
â”‚   â”‚   â”œâ”€â”€ application/
â”‚   â”‚   â”‚   â”œâ”€â”€ usecases/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ RebalancePortfolioUseCase.java   # Uses analytics recommendations
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ MonitorRiskUseCase.java
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ TrackPerformanceUseCase.java
â”‚   â”‚   â”‚   â””â”€â”€ dto/
â”‚   â”‚   â”‚       â”œâ”€â”€ PortfolioSnapshot.java
â”‚   â”‚   â”‚       â””â”€â”€ RebalanceReport.java
â”‚   â”‚   â”œâ”€â”€ infrastructure/
â”‚   â”‚   â”‚   â”œâ”€â”€ execution/
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ MockTradeExecutor.java        # Simulated trade execution
â”‚   â”‚   â”‚   â””â”€â”€ persistence/
â”‚   â”‚   â”‚       â””â”€â”€ entities/
â”‚   â”‚   â”‚           â”œâ”€â”€ PortfolioEntity.java
â”‚   â”‚   â”‚           â””â”€â”€ TradeEntity.java
â”‚   â”‚   â””â”€â”€ interfaces/
â”‚   â”‚       â”œâ”€â”€ rest/
â”‚   â”‚       â”‚   â””â”€â”€ PortfolioController.java
â”‚   â”‚       â””â”€â”€ camunda/
â”‚   â”‚           â””â”€â”€ RebalancePortfolioWorker.java
â”‚   â”‚
â”‚   â”œâ”€â”€ ğŸ”§ shared/                              # Shared Kernel
â”‚   â”‚   â”œâ”€â”€ kernel/
â”‚   â”‚   â”‚   â”œâ”€â”€ valueobjects/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Money.java                   # Common monetary value object
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Percentage.java              # Common percentage type
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ DateRange.java               # Common date range
â”‚   â”‚   â”‚   â”œâ”€â”€ exceptions/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ TradingPlatformException.java
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ValidationException.java
â”‚   â”‚   â”‚   â””â”€â”€ events/
â”‚   â”‚   â”‚       â”œâ”€â”€ DomainEvent.java             # Base event interface
â”‚   â”‚   â”‚       â””â”€â”€ EventPublisher.java          # Event publishing contract
â”‚   â”‚   â””â”€â”€ constants/
â”‚   â”‚       â”œâ”€â”€ TradingConstants.java            # Trading-specific constants
â”‚   â”‚       â””â”€â”€ ProcessVariables.java            # Camunda process variables
â”‚   â”‚
â”‚   â””â”€â”€ TradingPlatformApplication.java         # Main Spring Boot application
â”‚
â”œâ”€â”€ ğŸ“ src/main/resources/
â”‚   â”œâ”€â”€ application.yaml                        # Main configuration
â”‚   â”œâ”€â”€ camunda-processes/                      # BPMN workflow definitions
â”‚   â”‚   â”œâ”€â”€ fetch_instrument_data.bpmn
â”‚   â”‚   â”œâ”€â”€ run_trading_model.bpmn
â”‚   â”‚   â”œâ”€â”€ generate_forecast.bpmn
â”‚   â”‚   â””â”€â”€ rebalance_portfolio.bpmn
â”‚   â””â”€â”€ db/migration/                           # Database migrations
â”‚
â”œâ”€â”€ ğŸ“ src/test/java/
â”‚   â”œâ”€â”€ integration/                            # Cross-module integration tests
â”‚   â””â”€â”€ unit/                                   # Module-specific unit tests
â”‚
â”œâ”€â”€ ğŸ“„ compose.yaml                             # PostgreSQL database
â”œâ”€â”€ ğŸ“„ pom.xml                                  # Maven dependencies
â””â”€â”€ ğŸ“„ CLAUDE.md                                # Development guidelines
```

## ğŸ¯ **Module Responsibilities & Trading Model Flow**

### **ğŸ”„ 3-Phase Trading Model Implementation**

```mermaid
graph TD
    A[Market Data Module] -->|Historical Prices| B[Analytics Module]
    A -->|Historical Prices| C[Forecasting Module]
    
    C -->|Phase 3: Expected Returns| B
    B -->|Phase 1: Max Sharpe| D[Phase 2: Risk Adjustment]
    D -->|Risk-Adjusted Weights| E[Portfolio Module]
    
    B -->|Strategy Results| F[Backtesting Module]
    F -->|Validation Results| B
    
    E -->|Rebalance Orders| G[Trade Execution]
    
    H[Camunda Workflows] -.-> A
    H -.-> B
    H -.-> C
    H -.-> E
```

### **ğŸ“Š Module Bounded Contexts**

#### **âœ… Market Data Module (Completed)**
- **Domain**: Price data collection, validation, time-series management
- **Capabilities**: Bybit API integration, bulk data processing, rate limiting
- **External Task**: `fetch-instruments-data` topic
- **Database**: Asset-specific tables (btc_price_data, eth_price_data)

#### **ğŸ†• Analytics Module (Phase 1 & 2)**
- **Domain**: Modern Portfolio Theory implementation
- **Phase 1**: Maximum Sharpe Ratio optimization using quadratic programming
- **Phase 2**: Risk preference adjustment (Risk Averse/Neutral/Lover)
- **Input**: Expected returns, covariance matrix, constraints
- **Output**: Optimal portfolio weights

#### **ğŸ†• Forecasting Module (Phase 3)**
- **Domain**: Time series forecasting for expected returns
- **ARIMA Implementation**: Stationarity testing, parameter optimization, prediction
- **Statistical Tests**: Augmented Dickey-Fuller test for stationarity
- **Output**: Predicted expected returns for analytics module

#### **ğŸ†• Backtesting Module**
- **Domain**: Historical strategy validation
- **Performance Metrics**: Sharpe ratio, volatility, maximum drawdown
- **Simulation Types**: Vectorized backtesting for performance
- **Validation**: Strategy comparison and risk analysis

#### **ğŸ†• Portfolio Module**
- **Domain**: Real portfolio management and rebalancing
- **Capabilities**: Position tracking, trade execution, performance monitoring
- **Integration**: Uses analytics results for rebalancing decisions
- **Real-time**: Risk monitoring and performance tracking

## ğŸš€ **Key Architectural Benefits**

### **1. True Modularity** ğŸ†
- Each module is self-contained with domain, application, infrastructure, and interface layers
- Clear bounded contexts following DDD principles
- Independent testing and deployment capabilities

### **2. Modern Portfolio Theory Implementation** ğŸ“ˆ
- **Phase 1**: Sharpe ratio optimization using mathematical programming
- **Phase 2**: Risk preference adjustment for personalized strategies
- **Phase 3**: ARIMA forecasting for dynamic expected return estimation
- **Validation**: Comprehensive backtesting with performance metrics

### **3. Spring Boot Best Practices** âš™ï¸
- **Domain-Driven Design**: Clear separation of concerns
- **Spring Modulith**: Event-driven communication between modules
- **Camunda Integration**: Workflow orchestration for complex processes
- **Strategy Pattern**: Pluggable optimization algorithms and data sources

### **4. Financial Mathematics Integration** ğŸ”¢
- **Covariance Matrix**: Risk calculations using historical data
- **Quadratic Programming**: Optimization algorithms for portfolio weights
- **Statistical Testing**: Stationarity tests for time series analysis
- **Performance Metrics**: Sharpe ratio, volatility, drawdown calculations

### **5. Microservices Evolution Path** ğŸš€
- Each module can be extracted as independent microservice
- Event-driven communication already established
- Independent scaling based on computational requirements
- Technology heterogeneity (different optimization libraries per module)

## ğŸ¯ **Implementation Priority**

1. **âœ… Market Data Module**: Completed with bulk processing and strategy pattern
2. **ğŸ—ï¸ Analytics Module**: Implement Phase 1 & 2 of trading model
3. **ğŸ”® Forecasting Module**: Add Phase 3 ARIMA implementation
4. **ğŸ“Š Backtesting Module**: Validate strategies with historical data
5. **ğŸ’¼ Portfolio Module**: Real portfolio management using analytics results

This architecture provides a solid foundation for implementing Modern Portfolio Theory with proper separation of concerns, event-driven communication, and microservices readiness.